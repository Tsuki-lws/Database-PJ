# LLM评测平台后端开发指南

## 1. 数据库操作概述

本指南旨在帮助后端开发人员高效地使用LLM评测平台数据库进行开发。数据库设计采用了版本控制、软删除、关联关系等多种功能，合理使用这些功能可以简化开发流程并提高系统可靠性。

## 2. 数据模型与实体类

### 2.1 核心实体类

基于数据库设计，应实现以下核心实体类：

```java
// 原始问题
public class RawQuestion {
    private Integer questionId;
    private Integer sourceQuestionId;
    private String questionTitle;
    private String questionBody;
    private String source;
    private String sourceUrl;
    private Date crawledAt;
    private Date createdAt;
    private Date updatedAt;
    private Date deletedAt;
    
    // getter/setter...
}

// 标准问题
public class StandardQuestion {
    private Integer standardQuestionId;
    private String question;
    private Integer categoryId;
    private QuestionType questionType; // 枚举类型
    private DifficultyLevel difficulty; // 枚举类型
    private Integer sourceQuestionId;
    private QuestionStatus status; // 枚举类型
    private Integer version;
    private Date createdAt;
    private Date updatedAt;
    private Date deletedAt;
    
    // 关联属性
    private List<ObjectiveQuestionOption> options; // 对于客观题
    private List<StandardAnswer> answers;
    private List<Tag> tags;
    
    // getter/setter...
}

// 标准答案
public class StandardAnswer {
    private Integer standardAnswerId;
    private Integer standardQuestionId;
    private String answer;
    private Integer sourceAnswerId;
    private SourceType sourceType; // 枚举类型
    private Integer sourceId;
    private String selectionReason;
    private Integer selectedBy;
    private boolean isFinal;
    private Integer version;
    private Date createdAt;
    private Date updatedAt;
    private Date deletedAt;
    
    // 关联属性
    private List<AnswerKeyPoint> keyPoints;
    
    // getter/setter...
}
```

### 2.2 枚举类型

为确保代码一致性，应定义以下枚举类：

```java
public enum QuestionType {
    SINGLE_CHOICE("single_choice"),
    MULTIPLE_CHOICE("multiple_choice"),
    SIMPLE_FACT("simple_fact"),
    SUBJECTIVE("subjective");
    
    private String value;
    
    QuestionType(String value) {
        this.value = value;
    }
    
    public String getValue() {
        return value;
    }
    
    public static QuestionType fromValue(String value) {
        for (QuestionType type : values()) {
            if (type.value.equals(value)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Unknown QuestionType: " + value);
    }
}

// 同样方式定义其他枚举
public enum DifficultyLevel { EASY, MEDIUM, HARD }
public enum QuestionStatus { DRAFT, PENDING_REVIEW, APPROVED, REJECTED }
public enum SourceType { RAW, CROWDSOURCED, EXPERT, MANUAL }
public enum PointType { REQUIRED, BONUS, PENALTY }
// ...
```

## 3. DAO/Mapper层开发

### 3.1 基础DAO接口

对于每个实体，创建基础CRUD操作接口，例如：

```java
public interface StandardQuestionMapper {
    // 基本CRUD
    int insert(StandardQuestion question);
    StandardQuestion selectById(Integer id);
    List<StandardQuestion> selectAll();
    int updateById(StandardQuestion question);
    int deleteById(Integer id); // 软删除，设置deleted_at
    int physicalDeleteById(Integer id); // 物理删除，慎用
    
    // 高级查询
    List<StandardQuestion> selectByCategory(Integer categoryId);
    List<StandardQuestion> selectByType(QuestionType type);
    List<StandardQuestion> selectByDifficulty(DifficultyLevel difficulty);
    List<StandardQuestion> selectByTags(List<Integer> tagIds);
    
    // 版本相关
    int updateWithVersionIncrement(StandardQuestion question);
    List<StandardQuestionVersion> selectVersionHistory(Integer questionId);
}
```

### 3.2 MyBatis映射文件示例

```xml
<!-- StandardQuestionMapper.xml -->
<mapper namespace="com.llmeval.mapper.StandardQuestionMapper">
    <resultMap id="BaseResultMap" type="com.llmeval.entity.StandardQuestion">
        <id column="standard_question_id" property="standardQuestionId" />
        <result column="question" property="question" />
        <result column="category_id" property="categoryId" />
        <result column="question_type" property="questionType" 
                typeHandler="com.llmeval.typehandler.QuestionTypeHandler" />
        <!-- 其他字段映射 -->
        <collection property="options" ofType="com.llmeval.entity.ObjectiveQuestionOption"
                    column="standard_question_id" 
                    select="com.llmeval.mapper.ObjectiveQuestionOptionMapper.selectByQuestionId" />
    </resultMap>
    
    <insert id="insert" useGeneratedKeys="true" keyProperty="standardQuestionId">
        INSERT INTO standard_questions (
            question, category_id, question_type, difficulty, source_question_id, status
        ) VALUES (
            #{question}, #{categoryId}, #{questionType}, #{difficulty}, 
            #{sourceQuestionId}, #{status}
        )
    </insert>
    
    <update id="updateWithVersionIncrement">
        UPDATE standard_questions
        SET question = #{question},
            category_id = #{categoryId},
            question_type = #{questionType},
            difficulty = #{difficulty},
            status = #{status},
            version = version + 1,
            updated_at = NOW()
        WHERE standard_question_id = #{standardQuestionId}
          AND deleted_at IS NULL
    </update>
    
    <update id="deleteById">
        UPDATE standard_questions
        SET deleted_at = NOW()
        WHERE standard_question_id = #{id}
          AND deleted_at IS NULL
    </update>
    
    <!-- 其他SQL语句 -->
</mapper>
```

## 4. 服务层开发

### 4.1 服务接口设计

服务层应封装业务逻辑，处理事务和关联操作：

```java
public interface StandardQuestionService {
    StandardQuestion createQuestion(StandardQuestion question);
    StandardQuestion getQuestionById(Integer id);
    List<StandardQuestion> getQuestions(QuestionQuery query);
    StandardQuestion updateQuestion(StandardQuestion question, Integer userId, String reason);
    boolean deleteQuestion(Integer id);
    
    // 版本相关
    List<StandardQuestionVersion> getQuestionVersionHistory(Integer id);
    StandardQuestion revertToVersion(Integer questionId, Integer versionId);
    
    // 关联操作
    boolean addOptionToQuestion(Integer questionId, ObjectiveQuestionOption option);
    boolean updateOption(ObjectiveQuestionOption option, Integer userId, String reason);
    boolean deleteOption(Integer optionId);
    
    boolean addTagToQuestion(Integer questionId, Integer tagId);
    boolean removeTagFromQuestion(Integer questionId, Integer tagId);
}
```

### 4.2 服务实现示例

```java
@Service
public class StandardQuestionServiceImpl implements StandardQuestionService {
    
    @Autowired
    private StandardQuestionMapper questionMapper;
    
    @Autowired
    private ObjectiveQuestionOptionMapper optionMapper;
    
    @Autowired
    private StandardQuestionTagMapper questionTagMapper;
    
    @Autowired
    private StandardQuestionVersionMapper versionMapper;
    
    @Override
    @Transactional
    public StandardQuestion createQuestion(StandardQuestion question) {
        questionMapper.insert(question);
        
        // 处理选项
        if (question.getOptions() != null && !question.getOptions().isEmpty()) {
            for (ObjectiveQuestionOption option : question.getOptions()) {
                option.setStandardQuestionId(question.getStandardQuestionId());
                optionMapper.insert(option);
            }
        }
        
        return question;
    }
    
    @Override
    @Transactional
    public StandardQuestion updateQuestion(StandardQuestion question, Integer userId, String reason) {
        // 获取旧版本
        StandardQuestion oldQuestion = questionMapper.selectById(question.getStandardQuestionId());
        
        // 创建版本记录
        StandardQuestionVersion version = new StandardQuestionVersion();
        version.setStandardQuestionId(oldQuestion.getStandardQuestionId());
        version.setQuestion(oldQuestion.getQuestion());
        version.setCategoryId(oldQuestion.getCategoryId());
        version.setQuestionType(oldQuestion.getQuestionType());
        version.setDifficulty(oldQuestion.getDifficulty());
        version.setVersion(oldQuestion.getVersion());
        version.setChangedBy(userId);
        version.setChangeReason(reason);
        versionMapper.insert(version);
        
        // 执行更新（会自动增加版本号）
        questionMapper.updateWithVersionIncrement(question);
        
        // 更新选项（如果有）
        if (question.getOptions() != null) {
            // 这里应该实现选项的更新逻辑，包括版本控制
        }
        
        return questionMapper.selectById(question.getStandardQuestionId());
    }
    
    // 其他方法实现...
}
```

## 5. 存储过程的使用

数据库设计中包含了几个存储过程，用于处理版本更新。您可以通过以下方式在代码中调用：

```java
// 使用JdbcTemplate调用存储过程
@Autowired
private JdbcTemplate jdbcTemplate;

public void updateQuestionUsingProcedure(Integer questionId, String newQuestion, 
        Integer categoryId, String questionType, String difficulty, 
        Integer userId, String reason) {
        
    jdbcTemplate.execute(con -> {
        CallableStatement stmt = con.prepareCall(
                "{call update_standard_question(?, ?, ?, ?, ?, ?, ?)}");
        stmt.setInt(1, questionId);
        stmt.setString(2, newQuestion);
        stmt.setInt(3, categoryId);
        stmt.setString(4, questionType);
        stmt.setString(5, difficulty);
        stmt.setInt(6, userId);
        stmt.setString(7, reason);
        return stmt;
    });
}
```

## 6. 事务管理

由于数据库操作涉及多表更新和版本控制，务必妥善管理事务：

```java
@Transactional
public void complexOperation() {
    try {
        // 多表操作
        // ...
        
    } catch (Exception e) {
        // 记录异常，事务会自动回滚
        log.error("Operation failed", e);
        throw e;
    }
}
```

## 7. 分页查询实现

实现分页查询以优化大数据集的处理：

```java
// MyBatis分页插件
public PageInfo<StandardQuestion> getQuestionsByPage(QuestionQuery query, int pageNum, int pageSize) {
    PageHelper.startPage(pageNum, pageSize);
    List<StandardQuestion> questions = questionMapper.selectByQuery(query);
    return new PageInfo<>(questions);
}

// 对应的XML
<select id="selectByQuery" resultMap="BaseResultMap">
    SELECT * FROM standard_questions
    WHERE deleted_at IS NULL
    <if test="categoryId != null">
        AND category_id = #{categoryId}
    </if>
    <if test="questionType != null">
        AND question_type = #{questionType}
    </if>
    <if test="difficulty != null">
        AND difficulty = #{difficulty}
    </if>
    <if test="keyword != null and keyword != ''">
        AND question LIKE CONCAT('%', #{keyword}, '%')
    </if>
    ORDER BY updated_at DESC
</select>
```

## 8. 软删除处理

系统采用软删除机制，需要注意：

1. 默认查询条件应包含`deleted_at IS NULL`
2. 软删除操作实际是更新`deleted_at`字段
3. 物理删除仅用于特殊场景（如数据迁移）

```java
// 查询时过滤已删除记录
public List<StandardQuestion> getActiveQuestions() {
    return questionMapper.selectActive();
}

// 对应的XML
<select id="selectActive" resultMap="BaseResultMap">
    SELECT * FROM standard_questions WHERE deleted_at IS NULL
</select>

// 软删除操作
public boolean softDeleteQuestion(Integer id) {
    return questionMapper.deleteById(id) > 0;
}
```

## 9. 关联查询优化

处理复杂的关联关系时，可采用以下优化策略：

1. **延迟加载**：设置`lazyLoading=true`，避免不必要的关联查询
2. **选择性加载**：根据业务需求选择性地加载关联对象
3. **N+1问题避免**：使用JOIN或批量查询替代循环单次查询

```java
// 优化关联查询的方法示例
public StandardQuestion getQuestionWithDetails(Integer id, boolean includeOptions, 
        boolean includeAnswers, boolean includeTags) {
    
    StandardQuestion question = questionMapper.selectById(id);
    if (question == null) return null;
    
    // 选择性加载关联数据
    if (includeOptions) {
        question.setOptions(optionMapper.selectByQuestionId(id));
    }
    
    if (includeAnswers) {
        question.setAnswers(answerMapper.selectByQuestionId(id));
    }
    
    if (includeTags) {
        question.setTags(tagMapper.selectByQuestionId(id));
    }
    
    return question;
}
```

## 10. 类型处理器

对于枚举类型，应实现自定义TypeHandler：

```java
public class QuestionTypeHandler extends BaseTypeHandler<QuestionType> {
    
    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, QuestionType parameter, JdbcType jdbcType) 
            throws SQLException {
        ps.setString(i, parameter.getValue());
    }
    
    @Override
    public QuestionType getNullableResult(ResultSet rs, String columnName) throws SQLException {
        String value = rs.getString(columnName);
        return rs.wasNull() ? null : QuestionType.fromValue(value);
    }
    
    // 其他重写方法...
}
```

## 11. 常见业务场景代码示例

### 11.1 创建标准问题及选项

```java
@Transactional
public StandardQuestion createStandardQuestionWithOptions(StandardQuestionDTO dto) {
    // 创建标准问题
    StandardQuestion question = new StandardQuestion();
    BeanUtils.copyProperties(dto, question);
    question.setVersion(1);
    question.setStatus(QuestionStatus.DRAFT);
    questionMapper.insert(question);
    
    // 处理客观题选项
    if (QuestionType.SINGLE_CHOICE.equals(question.getQuestionType()) 
            || QuestionType.MULTIPLE_CHOICE.equals(question.getQuestionType())) {
        
        if (dto.getOptions() != null) {
            for (int i = 0; i < dto.getOptions().size(); i++) {
                ObjectiveQuestionOptionDTO optionDto = dto.getOptions().get(i);
                
                ObjectiveQuestionOption option = new ObjectiveQuestionOption();
                BeanUtils.copyProperties(optionDto, option);
                option.setStandardQuestionId(question.getStandardQuestionId());
                option.setOptionOrder(i);
                option.setVersion(1);
                
                optionMapper.insert(option);
            }
        }
    }
    
    // 处理标签
    if (dto.getTagIds() != null) {
        for (Integer tagId : dto.getTagIds()) {
            StandardQuestionTag tag = new StandardQuestionTag();
            tag.setStandardQuestionId(question.getStandardQuestionId());
            tag.setTagId(tagId);
            questionTagMapper.insert(tag);
        }
    }
    
    return question;
}
```

### 11.2 评测批次创建与执行

```java
@Transactional
public EvaluationBatch createAndStartBatch(EvaluationBatchDTO dto) {
    // 创建批次
    EvaluationBatch batch = new EvaluationBatch();
    BeanUtils.copyProperties(dto, batch);
    batch.setStatus("pending");
    batch.setCreatedAt(new Date());
    batchMapper.insert(batch);
    
    // 获取数据集问题
    List<Integer> questionIds = datasetQuestionMapper.selectQuestionIdsByVersion(dto.getVersionId());
    
    // 创建评测任务
    for (Integer questionId : questionIds) {
        // 获取问题和标准答案
        StandardQuestion question = questionMapper.selectById(questionId);
        StandardAnswer answer = answerMapper.selectFinalByQuestionId(questionId);
        
        // 调用模型生成回答
        String modelAnswer = modelService.generateAnswer(dto.getModelId(), question.getQuestion());
        
        // 保存LLM回答
        LlmAnswer llmAnswer = new LlmAnswer();
        llmAnswer.setModelId(dto.getModelId());
        llmAnswer.setStandardQuestionId(questionId);
        llmAnswer.setVersionId(dto.getVersionId());
        llmAnswer.setContent(modelAnswer);
        llmAnswer.setBatchId(batch.getBatchId());
        llmAnswer.setIsFinal(true);
        llmAnswerMapper.insert(llmAnswer);
        
        // 创建评测任务
        if ("auto".equals(dto.getEvaluationMethod())) {
            // 执行自动评测
            evaluationService.evaluateAnswer(llmAnswer.getLlmAnswerId(), answer.getStandardAnswerId(), 
                    dto.getEvaluationMethod(), batch.getBatchId());
        } else if ("judge_model".equals(dto.getEvaluationMethod()) && dto.getJudgeModelId() != null) {
            // 创建裁判模型评测任务
            judgeTaskMapper.createTask(batch.getBatchId(), llmAnswer.getLlmAnswerId(), 
                    answer.getStandardAnswerId(), dto.getJudgeModelId());
        }
    }
    
    // 更新批次状态
    batch.setStatus("in_progress");
    batch.setStartTime(new Date());
    batchMapper.updateById(batch);
    
    return batch;
}
```

## 12. 最佳实践建议

1. **使用存储过程**：对于涉及版本控制的更新操作，优先使用数据库提供的存储过程

2. **统一异常处理**：实现全局异常处理，确保数据库操作失败时能够提供有意义的错误信息

3. **缓存策略**：对于频繁查询的数据（如分类、标签），实现适当的缓存策略

4. **批量操作**：对于大量数据操作，使用批处理方式提高效率

5. **参数验证**：在服务层实施严格的参数验证，避免无效数据进入数据库

6. **密码处理**：确保用户密码使用强哈希算法（如BCrypt）存储，而不是明文

7. **审计日志**：记录关键操作的审计日志，包括操作人、操作时间和操作内容
